# import * as ed from 'npm:@noble/ed25519@1.7.1';
# const DISCORD_PUBLIC_KEY = Deno.env.get('DISCORD_PUBLIC_KEY') || '';
# const SUPABASE_URL = Deno.env.get('SUPABASE_URL') || '';
# const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || '';
# function hexToUint8(hex) {
#   if (!hex) return new Uint8Array();
#   const bytes = new Uint8Array(hex.length / 2);
#   for(let i = 0; i < bytes.length; i++){
#     bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
#   }
#   return bytes;
# }
# async function verifyDiscordRequest(req) {
#   if (!DISCORD_PUBLIC_KEY) return false;
#   const sig = req.headers.get('x-signature-ed25519');
#   const ts = req.headers.get('x-signature-timestamp');
#   if (!sig || !ts) return false;
#   const body = await req.text();
#   const message = new TextEncoder().encode(ts + body);
#   const signature = hexToUint8(sig);
#   const publicKey = hexToUint8(DISCORD_PUBLIC_KEY);
#   try {
#     return await ed.verify(signature, message, publicKey);
#   } catch (e) {
#     console.error('verification error', e);
#     return false;
#   }
# }
# function findOptionValue(options, targetName) {
#   if (!Array.isArray(options)) return null;
#   for (const opt of options){
#     if (opt.name === targetName && (typeof opt.value === 'string' || typeof opt.value === 'number' || typeof opt.value === 'boolean')) {
#       return String(opt.value);
#     }
#     // nested options (subcommands / groups)
#     if (Array.isArray(opt.options)) {
#       const v = findOptionValue(opt.options, targetName);
#       if (v !== null) return v;
#     }
#   }
#   return null;
# }
# async function insertCallout(content, discord_user_id, discord_username) {
#   if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) throw new Error('Missing Supabase env vars');
#   const url = `${SUPABASE_URL}/rest/v1/callouts`;
#   const body = {
#     content,
#     discord_user_id,
#     discord_username
#   };
#   const res = await fetch(url, {
#     method: 'POST',
#     headers: {
#       'Content-Type': 'application/json',
#       'apikey': SUPABASE_SERVICE_ROLE_KEY,
#       'Authorization': `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
#       'Prefer': 'return=representation'
#     },
#     body: JSON.stringify(body)
#   });
#   if (!res.ok) {
#     const txt = await res.text();
#     console.error('Failed to insert callout:', res.status, txt);
#     throw new Error(`Insert failed ${res.status}`);
#   }
#   return res.json();
# }
# console.info('Uranium Bot starting. Extracting...');
# Deno.serve(async (req)=>{
#   if (req.method !== 'POST') return new Response('Method Not Allowed', {
#     status: 405
#   });
#   // We'll clone for verification because we'll need the body again
#   const cloned = req.clone();
#   const isValid = await verifyDiscordRequest(cloned);
#   if (!isValid) return new Response('Bad request signature', {
#     status: 401
#   });
#   const body = await req.json();
#   if (body.type === 1) return new Response(JSON.stringify({
#     type: 1
#   }), {
#     headers: {
#       'Content-Type': 'application/json'
#     }
#   });
#   if (body.type === 2) {
#     const name = body.data?.name;
#     if (name === 'callout') {
#       // Try multiple ways to extract the reason input
#       let content = null;
#       // 1) primary: option named 'reason'
#       content = findOptionValue(body.data?.options, 'reason');
#       // 2) fallback: sometimes command uses 'message' or 'text' or first option
#       if (content === null) content = findOptionValue(body.data?.options, 'message');
#       if (content === null) content = findOptionValue(body.data?.options, 'text');
#       if (content === null && Array.isArray(body.data?.options) && body.data.options.length > 0) {
#         const first = body.data.options[0];
#         if (typeof first.value === 'string') content = first.value;
#         else if (Array.isArray(first.options)) {
#           // nested
#           const nestedFirst = first.options[0];
#           if (nestedFirst && typeof nestedFirst.value === 'string') content = nestedFirst.value;
#         }
#       }
#       // 3) final fallback: empty string so DB isn't null
#       if (content === null) content = '';
#       // Trim and limit length to avoid DB issues
#       content = content.trim().slice(0, 2000);
#       const discord_user_id = body.member?.user?.id || body.user?.id || null;
#       const discord_username = body.member?.user?.username || body.user?.username || null;
#       // Log for debugging — visible in Edge Function logs
#       console.info('Extracted content (reason):', content);
#       try {
#         await insertCallout(content, discord_user_id, discord_username);
#       } catch (e) {
#         console.error('DB insert error', e);
#         return new Response(JSON.stringify({
#           type: 4,
#           data: {
#             content: 'Sorry — failed to save your callout.'
#           }
#         }), {
#           headers: {
#             'Content-Type': 'application/json'
#           }
#         });
#       }
#       const usernameDisplay = discord_username || 'there';
#       const reply = `Callout saved for ${usernameDisplay}.`;
#       return new Response(JSON.stringify({
#         type: 4,
#         data: {
#           content: reply
#         }
#       }), {
#         headers: {
#           'Content-Type': 'application/json'
#         }
#       });
#     }
#     return new Response(JSON.stringify({
#       type: 4,
#       data: {
#         content: `Command ${name} received.`
#       }
#     }), {
#       headers: {
#         'Content-Type': 'application/json'
#       }
#     });
#   }
#   return new Response(null, {
#     status: 400
#   });
# });

# curl -X POST "https://discord.com/api/v10/applications/1418995463050231818/guilds/1418998799547896002/commands" -H "Authorization: Bot MTQxODk5NTQ2MzA1MDIzMTgxOA.GWhCjW.zBmZpjTEV4obDgTyvCX1_Y4j9ZeAOSYuDjjuIY" -H "Content-Type: application/json" -d '{"name":"callout","description":"Submit a callout reason.","options":[{"name":"reason","description":"Why you are submitting this callout","type":3,"required":true}, { "name": "month", "description": "Month", "type": 3, "required": true }, { "name": "Day", "description": "Day", "type": 3, "required": true }]}'
